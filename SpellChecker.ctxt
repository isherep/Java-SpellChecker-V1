#BlueJ class context
comment0.target=SpellChecker
comment0.text=\n\ The\ SpellChecker\ behaves\ as\ a\ spell\ checking\ program\ using\ the\ text\ file\ dictionary\ with\ the\ correct\ spelling\ of\ words.\n\ \n\ It\ will\ perform\ two\ types\ of\ corrections\ on\ the\ incoming\ word\ and\ then\ return\ the\ corrected\ word\:\n\ It\ fixes\ bad\ casing\:\ england\u201D\ \u2192\ \u201CEngland\u201D\n\ It\ removes\ invalid\ repeating\ characters\:\ \u201Ctabble\u201D\ \u2192\ \u201Ctable\u201D\n\ If\ the\ incoming\ word\ is\ already\ correct,\ the\ function\ should\ return\ the\ original\ word.\n\ If\ no\ correction\ can\ be\ found,\ \ the\ string\ \u201CNo\ Correction\ Found\u201D\ is\ returned.\n\ \n\ Assumes\ that\ any\ number\ of\ character\ duplication\ can\ be\ made,\ duplication\ can\ occur\ more\ than\ once,\ \n\ bad\ casing\ can\ occur\ more\ than\ one\ time\ in\ the\ word\ at\ any\ letter,\ word\ can\ have\ both\ casing\ and\ duplication\ errors\ at\ the\ same\ time\n\ If\ the\ two\ possible\ correct\ spellings\ of\ the\ word\ is\ possible,\ the\ function\ picks\ first\ one.\n\ \n\ SpellChecker\ corrects\ the\ word\ in\ a\ floowing\ way.\ \n\ It\ removes\ capitalization\ and\ any\ consecutive\ character\ duplication\ from\ the\ dictioaries\ words,\ puts\ them\ in\ the\ map\ as\ as\ keys.\ \n\ Removing\ capitalization\ and\ any\ consecutive\ character\ duplication\ from\ the\ misspelled\ word.\ \n\ that\ allows\ to\ select\ only\ the\ words\ from\ the\ dictionary\ that\ have\ the\ same\ sequence\ of\ characters\ as\ the\ misspelled\ word.\n\ \n\ Each\ key\ of\ of\ map\ will\ have\ a\ value\ a\ set\ of\ possible\ permutations\ of\ the\ key\ word\ according\ to\ dictionary.\n\ \n\ Using\ the\ smallest\ edit\ distance(modified\ Levenhstein\ algorithm)\ the\ function\ matches\ each\ permutation\ of\ the\ key\ to\ the\ misspelled\ word.\n\ The\ smallest\ edit\ distance\ is\ the\ correct\ spell\ of\ the\ word.\ \n\n\ \n\ @author\ Iryna\ Sherepot\n\ @version\ 03/14/2019\n
comment1.params=file
comment1.target=SpellChecker(java.lang.String)
comment1.text=\n\ Constructs\ a\ MultiMap\ representing\ dictionary\ of\ words\ from\ the\ given\ file.\n\ \n\ The\ keys\ in\ a\ map\ are\ dictionary\ words\ with\ no\ repeated\ characters\ and\ lowercased.\n\ The\ values\ in\ a\ mp\ are\ the\ list\ of\ words\ that\ can\ be\ made\ of\ the\ key.\n\ \n\ @param\ file\ the\ dictionary\ file\ of\ correct\ words\n
comment2.params=wordToCheck
comment2.target=java.lang.String\ checkWord(java.lang.String)
comment2.text=\n\ The\ function\ behaves\ as\ follows\:\n\ Performs\ two\ types\ of\ corrections\ on\ the\ incoming\ word\ and\ then\ return\ the\ corrected\ word\:\n\ It\ fixes\ bad\ casing\:\ \u201Cengland\u201D\ \u2192\ \u201CEngland\u201D\n\ It\ removes\ invalid\ repeating\ characters\:\u201Ctabble\u201D\ \u2192\ \u201Ctable\u201D\n\ If\ the\ incoming\ word\ is\ already\ correct,\ the\ function\ returns\ the\ original\ word.\n\ If\ no\ correction\ can\ be\ found,\ the\ function\ returns\ the\ string\ \u201CNo\ Correction\ Found\u201D.\n\ \n\ @param\ wordToCheck\ the\ word\ to\ be\ spell\ checked\ for\ bad\ casing\ and\ invalid\ character\ duplication\n\ \n\ @return\ the\ corrected\ word\ if\ the\ given\ word\ was\ misspelled;\ \ the\ original\ word\ the\ incoming\ word\ is\ already\ correct;\ "No\ Corrections\ Found"\ if\ no\ correct\ word\ is\ found\n
comment3.params=word
comment3.target=java.lang.String\ findClosestMatchingWord(java.lang.String)
comment3.text=\n\ Uses\ Levenshtein\ distance\ modified\ to\ allow\ only\ deletions\ to\ be\ made\ in\ order\ to\ match\ two\ words.\n\ Creates\ a\ key\ of\ a\ map\ that\ is\ a\ word\ without\ any\ duplicated\ characters.\n\ Iterates\ through\ the\ set\ of\ possible\ candidates\ for\ that\ key\ and\ selects\ a\ word\ with\ a\ minimum\ Levenshtein\ distance\n\ \n\ @param\ word\ the\ word\ to\ be\ looked\ the\ closest\ edit\ distance\ for.\ \n\ \n\ @return\ the\ word\ with\ the\ minimum\ Levenshtein\ edit\ distance\ -\ the\ correct\ word\n
comment4.params=word
comment4.target=java.lang.String\ makeCanonical(java.lang.String)
comment4.text=\n\ Removed\ duplicated\ consecutive\ characters\ from\ the\ word\n\ \n\ @param\ word\ the\ word\ to\ have\ duplication\ removed\n\ \n\ @return\ the\ word\ that\ doesn't\ contain\ any\ consecutive\ duplicated\ characters\n
comment5.params=lhs\ rhs
comment5.target=int\ modifiedLevenshteinDistance(java.lang.CharSequence,\ java.lang.CharSequence)
comment5.text=\n\ Implements\ modification\ of\ Levenshtein\ distance.\n\ Levenshtein\ algorithm\ returns\ the\ minimum\ edit\ distance\ between\ two\ words.\ \n\ Minimum\ edit\ distance\ -\ \ is\ the\ minimum\ number\ of\ single-character\ edits\ (i.e.,\ insertions,\ deletions\ or\ substitutions)\ \n\ required\ to\ change\ one\ word\ into\ the\ other.\n\ \n\ Original\ Levenshtein\ code\ has\ a\ cost\ of\ replacement,\ insertion,\ and\ deletion\ as\ 0\ and\ 1.\n\ Modified\ Levenshtein\ assigns\ the\ high\ values\ to\ the\ insertion\ and\ replacement,\n\ ensuring\ that\ only\ deletion\ to\ be\ the\ minimal\ distance\ option\ of\ edit\n\ \n\ This\ allows\ finding\ the\ word\ that\ matches\ given\ word\ including\ only\ deletions.\ \n\ \n\ @param\ lhs\ the\ character\ sequence\ matched\ against\ \n\ @param\ rhs\ the\ character\ sequence\ we\ are\ matching\n\ \n\ @return\ the\ minimal\ edit\ distance\ to\ turn\ sequence\ lrs\ into\ sequence\ rhs\n
comment6.params=filename
comment6.target=int\ countLinesInTextFile(java.lang.String)
comment6.text=\n\ Counts\ number\ of\ lines\ in\ the\ text\ file.\n\ Used\ to\ test\ if\ all\ the\ words\ form\ the\ file\ were\ inserted\ into\ the\ data\ stucture\n\ \n\ @param\ filename\ the\ file\ to\ be\ read\n\ \n\ @return\ number\ of\ lines\ in\ the\ test\ file\n
comment7.params=args
comment7.target=void\ main(java.lang.String[])
numComments=8
